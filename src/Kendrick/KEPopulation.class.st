"
A KEPopulation is a population splitted in several compartments  in which the disease is spreading.

Instance Variables
	compartments:		<Dictionary>
	individuals:		<OrderedCollection>
	diedIndList:		<OrderedCollection>
	attributes:   	         <Dictionary>
	relations: 		<OrderedCollection>
	subPopulations:   <Dictionary>

compartments
	- A collection of compartments in the population, each of them has a name generated by attributes and the set of equivalence relations of this population

individuals
	- A collection of individuals (instances of KEIndividual class)
	
attributes
         - A list of attributes of each individual in the population

relations
	- A set of equivalence relationship for partitioning the population in compartments
	
subPopulations
	- Each population can have a list of subPopulations. Each subPopulation is a part of Population in which the relationship and attributes are more complex, allowing to modelling at multi-scale


"
Class {
	#name : #KEPopulation,
	#superclass : #KEEntity,
	#instVars : [
		'compartments',
		'diedIndList',
		'individuals',
		'initialSize'
	],
	#category : #'Kendrick-Core'
}

{ #category : #accessing }
KEPopulation class >> size: aNumber [
	|population|
	population := self new.
	population initialSize: aNumber.
	^ population
]

{ #category : #adding }
KEPopulation >> addIndividual: ind [
	(self diedIndList isEmpty) 
	ifFalse: [ 
		ind id: (self diedIndList removeFirst).
		self individuals at: (ind id) put: ind
		]
	ifTrue: [  
		ind id: (self individuals size + 1).
		self individuals add: ind
		].
	
]

{ #category : #adding }
KEPopulation >> compartments [
	^ compartments
]

{ #category : #accessing }
KEPopulation >> compartments: aCollection [
	|dataOfComps|
	self compartments ifNil: [ compartments := Dictionary new ].
	aCollection isDictionary 
	ifFalse: [ 
		|reader|
		reader := STONReader on: aCollection readStream.
		reader allowComplexMapKeys: true.
		dataOfComps := reader next
	] 
	ifTrue: [ dataOfComps := aCollection ].
	dataOfComps keysAndValuesDo: [ :k :v|
		compartments at: k put: v
		 ].
	
 
	
]

{ #category : #accessing }
KEPopulation >> diedIndList [
	diedIndList ifNil: [ diedIndList := OrderedCollection new ].
	^ diedIndList 
	
]

{ #category : #accessing }
KEPopulation >> individuals [
	individuals ifNil: [ 
		|n|
		n := 0.
		individuals := OrderedCollection new.
		self compartments keysAndValuesDo: [ :k :v|
			1 to: v do: [ :i|
				|ind|
				ind := KEIndividual new.
				n := n + 1.
				ind updateAttributes: k.
				ind currentStatus: k.
				ind id: n.
				individuals add: ind
				 ]
			 ]
		 ].
	^ individuals
	
]

{ #category : #adding }
KEPopulation >> initialSize [
	^ initialSize 
]

{ #category : #adding }
KEPopulation >> initialSize: aNumber [
	initialSize := aNumber
]

{ #category : #adding }
KEPopulation >> removeIndividual: ind [
	ind attributes at: #alive put: false.
	self diedIndList add: ind id.
	self individuals at: (ind id) put: ind.
	
]

{ #category : #accessing }
KEPopulation >> reset [
	compartments := nil
]

{ #category : #accessing }
KEPopulation >> size [
	| s |
	s := 0.
	compartments do: [:each | s := s + each ].
	^ s
]

{ #category : #'as yet unclassified' }
KEPopulation >> sizeOfACompartment: aCompartmentName [
	^ self compartments at: aCompartmentName ifAbsent: [ ^ self error: 'No compartment name: ', aCompartmentName asString ]
	
	
	
	
]

{ #category : #'as yet unclassified' }
KEPopulation >> sizeOfCompartments: keys [
	|c|
	c := 0.
	self compartments keysAndValuesDo: [ :k :v|
		(k associations includesAll: keys) ifTrue: [ c := c + v ]
	].
	^ c
	
	
	
]

{ #category : #accessing }
KEPopulation >> sizeOfPopulation: array [
	| c |
	c := 0.
	self compartments
		keysAndValuesDo: [ :k :v | 
			(k values includesAll: array)
				ifTrue: [ c := c + v ] ].
	^ c
]

{ #category : #adding }
KEPopulation >> updateIndividual: ind [
	ind updateAttributes: ind nextStatus.
	ind currentStatus: ind nextStatus.
	ind nextStatus: nil
]
